# -*- coding: utf-8 -*-
"""Copia de Evidence 2 Agents.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tiTvKuEC8PxeaRx1i7BfDZa22lNPPFLf
"""

# !pip install agentpy
# !pip install random
# !pip install numpy
# !pip install matplotlib

import agentpy as ap
import numpy as np
import random
import matplotlib.pyplot as plt

class Drone(ap.Agent):
    def setup(self):
        """Initialize drone parameters"""
        self.grid = self.model.space
        self.landing_station = self.model.landing_station
        self.x = self.landing_station[0]
        self.y = self.landing_station[1]
        self.height = 0
        self.battery = 100
        self.is_flying = False
        self.is_controlled_by_security = False
        self.mission_completed = False
        self.target_height = 5
        self.chasing_robber = False
        self.target_robber = None
        self.detection_range = 3  # Can detect robbers 3 cells away

    def take_off(self):
        """Drone takes off from the landing station"""
        if self.x == self.landing_station[0] and self.y == self.landing_station[1] and self.height == 0:
            self.is_flying = True
            # Gradually increase height to target height
            self.height = self.target_height
            print(f"Drone {self.id} taking off from landing station at ({self.x}, {self.y}, height: {self.height})")
        else:
            print(f"Error: Drone cannot take off. Not at landing station or not at ground level.")

    def land(self):
        """Drone lands at the landing station"""
        if self.x == self.landing_station[0] and self.y == self.landing_station[1]:
            self.height = 0  # Return to ground level
            self.is_flying = False
            self.mission_completed = True
            print(f"Drone {self.id} landed at landing station at ({self.x}, {self.y}, height: {self.height})")
        else:
            # Force drone back to landing station before landing
            self.x = self.landing_station[0]
            self.y = self.landing_station[1]
            self.height = 0
            self.is_flying = False
            self.mission_completed = True
            print(f"Drone {self.id} forcibly returned and landed at landing station")

    def patrol(self):
        """Patrol the area, moving randomly and consuming battery"""
        if not self.is_flying:
            self.take_off()

        if self.is_flying:
            if self.chasing_robber:
                caught_up = self.chase_robber()
                if caught_up:
                    # Alert nearest security personnel
                    nearest_security = min(
                        [agent for agent in self.model.agents if isinstance(agent, SecurityPersonnel)],
                        key=lambda s: ((s.x - self.x)**2 + (s.y - self.y)**2)**0.5
                    )
                    nearest_security.alerted_to_robber = True
                    nearest_security.target_robber = self.target_robber
                    print(f"Drone {self.id} alerted security {nearest_security.id}")
            else:
                # Normal patrol movement
                self.x = max(0, min(self.model.grid_size-1,
                             self.x + random.choice([-1, 0, 1])))
                self.y = max(0, min(self.model.grid_size-1,
                             self.y + random.choice([-1, 0, 1])))

                # Randomly adjust height within constraints while patrolling
                height_change = random.choice([-1, 0, 1])
                self.height = max(self.target_height - 2,
                                min(self.target_height + 2,
                                    self.height + height_change))

            self.battery -= 1
            print(f"Drone {self.id} patrolling at ({self.x}, {self.y}, height: {self.height})")

    def inspect_area(self):
        """Inspect the area for suspicious activity with extended range"""
        for agent in self.model.agents:
            if isinstance(agent, Robber) and not agent.is_caught:
                # Calculate distance to robber
                distance = np.sqrt((self.x - agent.x)**2 + (self.y - agent.y)**2)
                if distance <= self.detection_range:
                    agent.is_spotted = True
                    self.chasing_robber = True
                    self.target_robber = agent
                    print(f"Drone {self.id} spotted robber at ({agent.x}, {agent.y}) from {distance:.1f} cells away")
                    return True
        return False

    def chase_robber(self):
        """Chase the spotted robber"""
        if self.target_robber and not self.target_robber.is_caught:
            # Calculate direction to move
            dx = self.target_robber.x - self.x
            dy = self.target_robber.y - self.y

            # Move towards robber
            if abs(dx) > 0:
                self.x += 1 if dx > 0 else -1
            if abs(dy) > 0:
                self.y += 1 if dy > 0 else -1

            # Keep within grid bounds
            self.x = max(0, min(self.model.grid_size-1, self.x))
            self.y = max(0, min(self.model.grid_size-1, self.y))

            print(f"Drone {self.id} chasing robber, current position: ({self.x}, {self.y})")

            # Check if caught up to robber
            if abs(self.x - self.target_robber.x) <= 1 and abs(self.y - self.target_robber.y) <= 1:
                print(f"Drone {self.id} caught up to robber!")
                return True
        return False

class Camera(ap.Agent):
    def setup(self):
        """Initialize camera at a random location"""
        self.x = random.randint(0, self.model.grid_size-1)
        self.y = random.randint(0, self.model.grid_size-1)
        self.detection_radius = 3
        self.last_detection_time = 0  # Track when last detection occurred
        self.detected_agents = set()  # Track which agents have been detected

    def detect_movement(self, agent):
        """Detect if any agent (drone or robber) is within detection radius"""
        distance = np.sqrt((self.x - agent.x)**2 + (self.y - agent.y)**2)

        if distance <= self.detection_radius:
            current_time = self.model.current_step

            # Only report new detections or if enough time has passed
            if agent.id not in self.detected_agents or (current_time - self.last_detection_time) > 2:
                self.detected_agents.add(agent.id)
                self.last_detection_time = current_time

                if isinstance(agent, Robber):
                    print(f"Camera {self.id} detected suspicious movement from robber at ({agent.x}, {agent.y})")
                    # Alert nearest drone
                    self.alert_drone(agent)
                elif isinstance(agent, Drone):
                    print(f"Camera {self.id} detected drone movement at ({agent.x}, {agent.y})")

                return True
        else:
            # Remove from detected agents if out of range
            self.detected_agents.discard(agent.id)

        return False

    def alert_drone(self, robber):
        """Alert the nearest drone about detected robber"""
        nearest_drone = None
        min_distance = float('inf')

        # Find nearest drone
        for agent in self.model.agents:
            if isinstance(agent, Drone):
                distance = np.sqrt((self.x - agent.x)**2 + (self.y - agent.y)**2)
                if distance < min_distance:
                    min_distance = distance
                    nearest_drone = agent

        if nearest_drone and not nearest_drone.chasing_robber:
            nearest_drone.target_robber = robber
            nearest_drone.chasing_robber = True
            print(f"Camera {self.id} alerted drone {nearest_drone.id} about robber at ({robber.x}, {robber.y})")

            # Find nearest security personnel to assist
            nearest_security = min(
                [s for s in self.model.agents if isinstance(s, SecurityPersonnel) and not s.chasing_robber],
                key=lambda s: ((s.x - robber.x)**2 + (s.y - robber.y)**2)**0.5,
                default=None
            )

            if nearest_security:
                nearest_security.alerted_to_robber = True
                nearest_security.target_robber = robber
                print(f"Camera {self.id} alerted security {nearest_security.id} to assist with robber")

    def scan_area(self):
        """Actively scan area for any agents"""
        for agent in self.model.agents:
            if isinstance(agent, (Robber, Drone)):
                self.detect_movement(agent)

class SecurityPersonnel(ap.Agent):
    def setup(self):
        """Initialize security personnel parameters"""
        self.x = random.randint(0, self.model.grid_size-1)
        self.y = random.randint(0, self.model.grid_size-1)
        self.has_drone_control = False
        self.chasing_robber = False
        self.target_robber = None
        self.alerted_to_robber = False
        self.movement_speed = 1  # Cells per step

    def patrol(self):
        """Patrol the area randomly"""
        if not self.chasing_robber:
            self.x = max(0, min(self.model.grid_size-1,
                         self.x + random.choice([-1, 0, 1])))
            self.y = max(0, min(self.model.grid_size-1,
                         self.y + random.choice([-1, 0, 1])))
            print(f"Security {self.id} patrolling at ({self.x}, {self.y})")

    def take_drone_control(self, drone):
        """Take control of a drone"""
        self.has_drone_control = True
        drone.is_controlled_by_security = True
        print(f"Security personnel {self.id} took control of drone {drone.id}")

    def release_drone_control(self, drone):
        """Release control of a drone"""
        self.has_drone_control = False
        drone.is_controlled_by_security = False
        print(f"Security personnel {self.id} released control of drone {drone.id}")

    def chase_robber(self, robber):
        """Chase and try to catch the robber with increased urgency"""
        self.chasing_robber = True
        self.target_robber = robber

        # Calculate direction to robber
        dx = robber.x - self.x
        dy = robber.y - self.y

        # Move up to 2 cells per turn when chasing
        moves_left = 2
        while moves_left > 0 and not robber.is_caught:
            if abs(dx) > 0:
                self.x += 1 if dx > 0 else -1
                dx = robber.x - self.x
            if abs(dy) > 0:
                self.y += 1 if dy > 0 else -1
                dy = robber.y - self.y
            moves_left -= 1

            # Keep within grid bounds
            self.x = max(0, min(self.model.grid_size-1, self.x))
            self.y = max(0, min(self.model.grid_size-1, self.y))

            # Check if caught robber
            if abs(self.x - robber.x) <= 1 and abs(self.y - robber.y) <= 1:
                print(f"Security {self.id} caught robber {robber.id}!")
                robber.is_caught = True
                self.chasing_robber = False
                self.target_robber = None
                self.alerted_to_robber = False
                return True

        return False

    def assess_threat(self, drone):
        """Assess if drone's area inspection reveals a threat"""
        is_threat = drone.inspect_area()
        if is_threat:
            print(f"SECURITY ALERT: Suspicious activity detected by security personnel {self.id}!")
            return True
        print(f"False alarm by security personnel {self.id}")
        return False

class Robber(ap.Agent):
    def setup(self):
        """Initialize robber parameters"""
        self.x = random.randint(0, self.model.grid_size-1)
        self.y = random.randint(0, self.model.grid_size-1)
        self.is_caught = False
        self.is_spotted = False
        self.detection_range = 3  # Range at which robber can detect others

    def move(self):
        """Move while trying to avoid detection"""
        if not self.is_caught:
            # Get positions of nearby drones and security
            nearby_threats = self.check_nearby_threats()

            if nearby_threats:
                # Move away from threats
                self.evade_threats(nearby_threats)
            else:
                # Random movement if no threats nearby
                self.x = max(0, min(self.model.grid_size-1,
                             self.x + random.choice([-1, 0, 1])))
                self.y = max(0, min(self.model.grid_size-1,
                             self.y + random.choice([-1, 0, 1])))

            print(f"Robber {self.id} moving to ({self.x}, {self.y})")

    def check_nearby_threats(self):
        """Check for nearby drones and security personnel"""
        threats = []
        for agent in self.model.agents:
            if isinstance(agent, (Drone, SecurityPersonnel)):
                distance = np.sqrt((self.x - agent.x)**2 + (self.y - agent.y)**2)
                if distance <= self.detection_range:
                    threats.append((agent.x, agent.y))
        return threats

    def evade_threats(self, threats):
        """Move away from detected threats"""
        avg_threat_x = sum(t[0] for t in threats) / len(threats)
        avg_threat_y = sum(t[1] for t in threats) / len(threats)

        # Move in opposite direction of threats
        self.x += -1 if self.x < avg_threat_x else 1
        self.y += -1 if self.y < avg_threat_y else 1

        # Ensure we stay within grid bounds
        self.x = max(0, min(self.model.grid_size-1, self.x))
        self.y = max(0, min(self.model.grid_size-1, self.y))

class SurveillanceModel(ap.Model):
    def setup(self):
        """Initialize the simulation environment"""
        self.space = ap.Space(self, shape=[self.p.grid_size, self.p.grid_size])
        self.grid_size = self.p.grid_size
        self.landing_station = (self.grid_size // 2, self.grid_size // 2)
        self.drones = ap.AgentList(self, self.p.num_drones, Drone)
        self.cameras = ap.AgentList(self, self.p.num_cameras, Camera)
        self.security = ap.AgentList(self, self.p.num_security, SecurityPersonnel)
        self.robbers = ap.AgentList(self, self.p.num_robbers, Robber)
        self.agents = self.drones + self.cameras + self.security + self.robbers
        self.grid = np.zeros((self.grid_size, self.grid_size))
        self.current_step = 0
        self.return_initiated = False
        plt.figure(figsize=(10, 10))

    def calculate_manhattan_distance_to_landing(self, drone):
        """Calculate Manhattan distance from drone to landing station"""
        return abs(drone.x - self.landing_station[0]) + abs(drone.y - self.landing_station[1])

    def should_initiate_return(self, drone):
        """Determine if drone should start returning based on remaining steps and distance"""
        distance_to_landing = self.calculate_manhattan_distance_to_landing(drone)
        steps_remaining = self.p.steps - self.current_step
        # Add a small buffer to ensure safe return
        return steps_remaining <= distance_to_landing + 2

    def move_towards_landing_station(self, drone):
        """Move the drone one step closer to landing station"""
        if drone.x < self.landing_station[0]:
            drone.x += 1
        elif drone.x > self.landing_station[0]:
            drone.x -= 1
        elif drone.y < self.landing_station[1]:
            drone.y += 1
        elif drone.y > self.landing_station[1]:
            drone.y -= 1

        # Gradually decrease height as we approach landing station
        if self.calculate_manhattan_distance_to_landing(drone) < 3:
            drone.height = max(0, drone.height - 1)
        print(f"Drone returning to base. Position: ({drone.x}, {drone.y}, height: {drone.height})")

    def visualize(self):
        """Visualize the current state of the simulation"""
        plt.clf()
        self.grid = np.zeros((self.grid_size, self.grid_size))
        self.grid[self.landing_station[1], self.landing_station[0]] = 3

        # Plot cameras
        for camera in self.cameras:
            self.grid[camera.y, camera.x] = 2

        # Create custom colormap
        colors = ['white', 'red', 'blue', 'green', 'yellow', 'black']  # Added colors for security and robber
        from matplotlib.colors import ListedColormap
        custom_cmap = ListedColormap(colors)

        plt.imshow(self.grid, cmap=custom_cmap)
        plt.plot(self.landing_station[0], self.landing_station[1], 'gs',
                markersize=15, label='Landing Station')

        # Plot drone
        drone = self.drones[0]
        marker_size = 5 + (drone.height * 2)
        plt.plot(drone.x, drone.y, 'ro', markersize=marker_size,
                label=f'Drone (h={drone.height}m)')

        # Plot cameras
        for camera in self.cameras:
            plt.plot(camera.x, camera.y, 'bo', markersize=5)

        # Plot security personnel
        for security in self.security:
            plt.plot(security.x, security.y, 'ys', markersize=10,
                    label='Security' if security == self.security[0] else "")

        # Plot robbers (if not caught)
        for robber in self.robbers:
            if not robber.is_caught:
                plt.plot(robber.x, robber.y, 'ks', markersize=8,
                        label='Robber' if robber == self.robbers[0] else "")

        plt.title(f'Step {self.current_step} - Drone Height: {drone.height}m')
        plt.xlabel('X Coordinate')
        plt.ylabel('Y Coordinate')
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.legend(loc='best')
        plt.pause(0.1)

    def step(self):
      """Perform one step of the simulation"""
      self.current_step += 1
      drone = self.drones[0]

      # Move robbers first
      for robber in self.robbers:
          if not robber.is_caught:
              robber.move()

      # Security personnel patrol or chase
      for security in self.security:
          if security.alerted_to_robber:
              caught = security.chase_robber(security.target_robber)
              if caught:
                  # Reset drone's chase state
                  for drone in self.drones:
                      if drone.target_robber == security.target_robber:
                          drone.chasing_robber = False
                          drone.target_robber = None
                  security.release_drone_control(drone)
          else:
              security.patrol()

      # Check if drone needs to return to base
      if self.should_initiate_return(drone) and not self.return_initiated:
          print(f"Initiating return sequence at step {self.current_step}")
          self.return_initiated = True
          drone.chasing_robber = False
          drone.target_robber = None
          for security in self.security:
              if security.has_drone_control:
                  security.release_drone_control(drone)

      # Handle drone movement and detection
      if self.return_initiated:
          self.move_towards_landing_station(drone)
          if (drone.x == self.landing_station[0] and
              drone.y == self.landing_station[1]):
              print("Drone has reached landing station. Landing...")
              drone.land()
              self.visualize()
              return False
      elif not drone.is_controlled_by_security:
          drone.patrol()

          # First check for robbers
          if drone.inspect_area() and not drone.chasing_robber:
              # Start chasing if robber detected
              drone.chasing_robber = True

          # Then handle camera detection
          for camera in self.cameras:
              if camera.detect_movement(drone):
                  if not drone.is_controlled_by_security:
                      # Find nearest security personnel
                      nearest_security = min(
                          [s for s in self.security if not s.chasing_robber],
                          key=lambda s: ((s.x - drone.x)**2 + (s.y - drone.y)**2)**0.5,
                          default=None
                      )

                      if nearest_security:
                          nearest_security.take_drone_control(drone)
                          threat_detected = nearest_security.assess_threat(drone)

                          if threat_detected:
                              print(f"Camera {camera.id} detected potential threat!")
                          else:
                              print(f"Camera {camera.id} detection was a false alarm")
                              nearest_security.release_drone_control(drone)

      # Camera movement detection for robbers
      for camera in self.cameras:
        camera.scan_area()
          # for robber in self.robbers:
          #     if not robber.is_caught:
          #         distance = np.sqrt((camera.x - robber.x)**2 + (camera.y - robber.y)**2)
          #         if distance <= camera.detection_radius:
          #             print(f"Camera {camera.id} detected suspicious movement!")
          #             # Alert nearest drone if not already chasing
          #             if not drone.chasing_robber:
          #                 drone.target_robber = robber
          #                 drone.chasing_robber = True
          #                 print(f"Camera {camera.id} alerted drone to suspicious activity")

      self.visualize()
      return True

parameters = {
    'grid_size': 20,
    'num_drones': 1,
    'num_cameras': 3,
    'num_security': 2,
    'num_robbers': 1,
    'steps': 50  # Maximum number of steps
}

model = SurveillanceModel(parameters)
results = model.run(steps=parameters['steps'])

plt.show()
print(f"Simulation completed in {model.current_step} steps")

